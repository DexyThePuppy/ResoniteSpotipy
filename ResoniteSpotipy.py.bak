import asyncio as aio
import websockets.asyncio.server as ws_server
import websockets.asyncio.client as ws_client
import websockets.exceptions as ws_exceptions
import spotipy as sp
import signal
import curses
import sys
import os
import time
from datetime import datetime
import threading
from loguru import logger
import aiohttp
import json
import re
import requests

# Import libraries for caching
from diskcache import Cache
from requests_cache import CachedSession
import functools

from APIClient import APIClient  # The class that handles the Spotify API and custom functions
from resonite_ui import SpotipyUI
# Import the color extraction module
import spotify_color

# Global variables
API: sp.Spotify = None
CLIENT: APIClient = None
PORT: int = 0000
UI = None
DEBUG = False
# Variable to store the current screen mode we're displaying
DISPLAY: str = ""

# Spotify Canvas API endpoint
CANVAS_API_URL = "https://spotifycanvas-indol.vercel.app/api/canvas"

# Initialize caches
# General purpose disk cache for function results
disk_cache = Cache("spotify_cache")
# HTTP request cache with TTL of 1 hour for most requests
spotify_session = CachedSession(
    "spotify_http_cache",
    backend="sqlite",
    expire_after=3600,  # 1 hour cache expiration
    allowable_methods=('GET', 'POST'),  # Cache both GET and POST requests
)

# Set up caching for track ID extraction - memory-based lru_cache for speed
extract_track_id_cache = functools.lru_cache(maxsize=1000)

# Decorator for caching function results
def cache_result(ttl=3600):  # Default TTL: 1 hour
    """Cache function results to disk with timeout"""
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # Create a cache key from function name and arguments
            key = f"{func.__name__}:{str(args)}:{str(kwargs)}"
            
            # Try to get result from cache
            result = disk_cache.get(key)
            if result is not None:
                if DEBUG:
                    logger.debug(f"Cache hit for {func.__name__}")
                return result
                
            # Not in cache, execute function
            if DEBUG:
                logger.debug(f"Cache miss for {func.__name__}")
            result = func(*args, **kwargs)
            
            # Store in cache with TTL
            disk_cache.set(key, result, expire=ttl)
            return result
        return wrapper
    return decorator

# Async decorator for caching async function results
def async_cache_result(ttl=3600):  # Default TTL: 1 hour
    """Cache async function results to disk with timeout"""
    def decorator(func):
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            # Create a cache key from function name and arguments
            key = f"{func.__name__}:{str(args)}:{str(kwargs)}"
            
            # Try to get result from cache
            result = disk_cache.get(key)
            if result is not None:
                if DEBUG:
                    logger.debug(f"Cache hit for {func.__name__}")
                return result
                
            # Not in cache, execute function
            if DEBUG:
                logger.debug(f"Cache miss for {func.__name__}")
            result = await func(*args, **kwargs)
            
            # Store in cache with TTL
            disk_cache.set(key, result, expire=ttl)
            return result
        return wrapper
    return decorator

def current_time():
    return f"[{datetime.now():%H:%M:%S}]"

# Configurable settings
LOG_DEBUG_MESSAGES = True  # Whether to log debug messages to UI

# Memory monitoring using pympler
try:
    from pympler import tracker
    memory_tracker = tracker.SummaryTracker()
    MEMORY_TRACKING = True
except ImportError:
    MEMORY_TRACKING = False

def log_memory_usage():
    """Log memory usage information"""
    if not MEMORY_TRACKING:
        return
        
    try:
        memory_tracker.print_diff()
        
        # More detailed object tracking
        from pympler import asizeof
        if CLIENT:
            logger.debug(f"CLIENT size: {asizeof.asizeof(CLIENT)/1024:.1f} KB")
        if UI:
            logger.debug(f"UI size: {asizeof.asizeof(UI)/1024:.1f} KB")
    except Exception as e:
        logger.error(f"Error tracking memory: {e}")

@async_cache_result(ttl=3600)  # Cache Canvas data for 1 hour
async def fetch_spotify_canvas(session, track_id):
    """Fetch Spotify Canvas data for a track using the Canvas API.
    
    Args:
        session: aiohttp ClientSession
        track_id: Spotify track ID (not the full URI)
        
    Returns:
        Tuple of (canvas_url, artist_img_url) if found, (None, None) otherwise
    """
    try:
        logger.debug(f"Fetching Canvas data for track: {track_id}")
        
        # Make request to the Canvas API
        url = f"{CANVAS_API_URL}?trackId={track_id}"
        async with session.get(url) as response:
            if response.status != 200:
                logger.warning(f"Canvas API returned status {response.status}")
                return None, None
                
            # Parse the JSON response
            data = await response.text()
            canvas_data = json.loads(data)
            
            # Check if canvas data exists
            if canvas_data and "canvasesList" in canvas_data and len(canvas_data["canvasesList"]) > 0:
                canvas_url = canvas_data["canvasesList"][0].get("canvasUrl")
                artist_data = canvas_data["canvasesList"][0].get("artist", {})
                artist_img_url = artist_data.get("artistImgUrl")
                artist_name = artist_data.get("artistName")
                
                if canvas_url:
                    logger.info(f"Canvas found for track {track_id}: {canvas_url}")
                    if UI:
                        UI.add_log(f"Canvas video available for current track")
                    
                    # Also log artist info if available
                    if artist_name and artist_img_url:
                        logger.info(f"Artist image for {artist_name}: {artist_img_url}")
                        
                    return canvas_url, artist_img_url
            
            logger.info(f"No canvas found for track {track_id}")
            if UI:
                UI.add_log("No canvas video found for current track")
            return None, None
            
    except Exception as e:
        logger.error(f"Error fetching Spotify Canvas: {e}")
        return None, None

@async_cache_result(ttl=86400)  # Cache artist images for 24 hours as they rarely change
async def get_artist_image(artist_id):
    """Get artist image using the Spotify API.
    
    Args:
        artist_id: Spotify artist ID
        
    Returns:
        Artist image URL or None if not available
    """
    try:
        if not API:
            logger.warning("Spotify API not initialized")
            return None
            
        # Get artist data
        artist_data = API.artist(artist_id)
        
        # Extract image URL (get the first image if available)
        if artist_data and "images" in artist_data and len(artist_data["images"]) > 0:
            image_url = artist_data["images"][0]["url"]
            logger.info(f"Artist image found: {image_url}")
            return image_url
            
        logger.info(f"No artist image found for {artist_id}")
        return None
    except Exception as e:
        logger.error(f"Error getting artist image: {e}")
        return None

@extract_track_id_cache
def extract_track_id(track_uri):
    """Extract the track ID from a Spotify track URI or URL.
    
    Args:
        track_uri: Spotify track URI (e.g., "spotify:track:3OHfY25tqY28d16oZczHc8")
                  or URL (e.g., "https://open.spotify.com/track/3OHfY25tqY28d16oZczHc8")
    
    Returns:
        Track ID or None if extraction failed
    """
    try:
        # Handle URI format (spotify:track:ID)
        if track_uri.startswith("spotify:track:"):
            return track_uri.split(":")[-1]
        
        # Handle URL format (https://open.spotify.com/track/ID)
        match = re.search(r'track/([a-zA-Z0-9]+)', track_uri)
        if match:
            return match.group(1)
            
        # Maybe it's already just the ID
        if re.match(r'^[a-zA-Z0-9]{22}$', track_uri):
            return track_uri
            
        return None
    except Exception as e:
        logger.error(f"Error extracting track ID: {e}")
        return None

# Reads data from the IDs.txt file and parses them to be used in the API
def connect_to_spotify():
    global API, CLIENT, PORT
    
    logger.info("Starting Spotify authentication process")
    
    results: list[str | int] = ["", "", "", 0]
    indices: list[int]       = [1, 2, 5, 9]
    
    try:
        with open("IDs.txt") as file:
            lines: list[str] = file.readlines()
        
        for i in range(0, 4):
            results[i] = lines[indices[i]].split(" ")[2].removesuffix("\n").replace("<", "").replace(">", "")
            i += 1
        PORT = int(results[3])
        
        if (str(results[3]) in results[2]):
            raise Exception(f"Invalid port! ({PORT = }). Use a different port than the one used by the callback URI.")
        
        # Log auth information (hide sensitive info)
        client_id_safe = results[0][:4] + "..." + results[0][-4:] if len(results[0]) > 8 else "***"
        redirect_uri_safe = results[2]
        logger.info(f"Auth config - Client ID: {client_id_safe}, Redirect URI: {redirect_uri_safe}, Port: {PORT}")
        
        _ = """user-library-modify,user-library-read,user-read-currently-playing,user-read-playback-position,
                user-read-playback-state,user-modify-playback-state,app-remote-control,streaming,playlist-read-private,
                playlist-modify-private,playlist-modify-public,playlist-read-collaborative"""
        CLIENT = APIClient(results[0], results[1], results[2], _)
        API = CLIENT._api
        CLIENT._debug = DEBUG
        
        # Log auth success
        logger.info("Spotify authentication successful")
        if UI:
            UI.add_log("Spotify authentication successful")
        
        # Always call find_device to select an active device
        # This is critical for Spotify API functionality
        logger.info("Selecting Spotify device")
        CLIENT.find_device()
        
        # Get device info for logging after selection
        devices_info = find_spotify_devices()
        if UI and devices_info:
            UI.add_log(devices_info)
        
        return True
    except Exception as e:
        logger.error(f"Error connecting to Spotify: {str(e)}")
        if UI:
            UI.add_log(f"[ERROR] Failed to connect to Spotify: {str(e)}")
        return False

def find_spotify_devices():
    """Find and return information about available Spotify devices"""
    if not API:
        return "No Spotify API available to check devices"
    
    try:
        devices = API.devices()
        if not devices or not devices.get('devices'):
            return "No active Spotify devices found. Please open Spotify on one of your devices."
        
        devices_list = devices['devices']
        active_device = next((d for d in devices_list if d.get('is_active')), None)
        
        if active_device:
            return f"Active Spotify device: {active_device['name']} ({active_device['type']}) - Volume: {active_device['volume_percent']}%"
        else:
            devices_info = ", ".join([f"{d['name']} ({d['type']})" for d in devices_list[:3]])
            if len(devices_list) > 3:
                devices_info += f" and {len(devices_list) - 3} more"
            return f"Available Spotify devices: {devices_info}. No active device."
    except Exception as e:
        logger.error(f"Error getting Spotify devices: {str(e)}")
        return f"Error checking Spotify devices: {str(e)}"

# Displays current information about the currently playing track and/or the playback states
async def display_current_info(received: str, session=None) -> str:
    payload: str = ""
    
    match (received):
        case "current_info": # Used for getting the currently playing track and the playback states
            try:
                current_track = API.current_user_playing_track()
                
                # Special case: we're connected to Spotify but nothing is playing
                if not current_track:
                    # Try to get just the playback states
                    try:
                        playback_states = CLIENT.get_playback_states()
                        return f"[INFO] No track currently playing\n{playback_states}"
                    except Exception as e:
                        logger.warning(f"No playback states available: {str(e)}")
                        return "[ERROR] No current song active - Please play something in Spotify first"
                
                # Make sure we have a valid item
                if 'item' not in current_track or not current_track['item']:
                    return "[ERROR] No current song active - Please play something in Spotify first"
                
                # Get track data and playback states
                payload = CLIENT.get_track_data(current_track, ws_call="current") + "\n" + CLIENT.get_playback_states()
                
                # Get Canvas data if we have an HTTP session
                if session and current_track and 'item' in current_track and current_track['item']:
                    track_id = current_track['item'].get('id')
                    if track_id:
                        try:
                            canvas_url, artist_img_url = await fetch_spotify_canvas(session, track_id)
                            
                            # Add canvas URL to payload if found
                            if canvas_url:
                                payload += f"\n[CANVAS_URL]{canvas_url}"
                            
                            # Add artist image URL to payload if found
                            if artist_img_url:
                                payload += f"\n[ARTIST_IMG]{artist_img_url}"
                            
                            # If no artist image from canvas, try getting it directly from Spotify API
                            elif 'artists' in current_track['item'] and len(current_track['item']['artists']) > 0:
                                artist_id = current_track['item']['artists'][0]['id']
                                try:
                                    artist_img = await get_artist_image(artist_id)
                                    if artist_img:
                                        payload += f"\n[ARTIST_IMG]{artist_img}"
                                except Exception as e:
                                    logger.warning(f"Error fetching artist image: {str(e)}")
                        except Exception as e:
                            logger.warning(f"Error fetching canvas data: {str(e)}")
                
            except ValueError as e:
                logger.warning(f"No current song active: {str(e)}")
                if UI:
                    UI.add_log("No current song active - Try playing something in Spotify first")
                payload = "[ERROR] No current song active - Please play something in Spotify first"
            except Exception as e:
                error_msg = f"Error getting current track info: {str(e)}"
                logger.error(error_msg)
                if UI:
                    UI.add_log(error_msg)
                payload = f"[ERROR] {error_msg}"
        
        case "current_track":
            try:
                current_track = API.current_user_playing_track()
                if not current_track or 'item' not in current_track:
                    raise ValueError("No active track found")
                
                _ = current_track['item'] # Throws an error if there's no currently playing track
                
                # Get basic track data
                payload = CLIENT.get_track_data(current_track, ws_call="current")
                
                # Get Canvas data if we have an HTTP session
                if session and 'item' in current_track and current_track['item']:
                    track_id = current_track['item'].get('id')
                    if track_id:
                        try:
                            canvas_url, artist_img_url = await fetch_spotify_canvas(session, track_id)
                            
                            # Add canvas URL to payload if found
                            if canvas_url:
                                payload += f"\n[CANVAS_URL]{canvas_url}"
                            
                            # Add artist image URL to payload if found
                            if artist_img_url:
                                payload += f"\n[ARTIST_IMG]{artist_img_url}"
                            
                            # If no artist image from canvas, try getting it directly from Spotify API
                            elif 'artists' in current_track['item'] and len(current_track['item']['artists']) > 0:
                                artist_id = current_track['item']['artists'][0]['id']
                                try:
                                    artist_img = await get_artist_image(artist_id)
                                    if artist_img:
                                        payload += f"\n[ARTIST_IMG]{artist_img}"
                                except Exception as e:
                                    logger.warning(f"Error fetching artist image: {str(e)}")
                        except Exception as e:
                            logger.warning(f"Error fetching canvas data: {str(e)}")
                
            except ValueError as e:
                logger.warning(f"No current song active: {str(e)}")
                if UI:
                    UI.add_log("No current song active")
                payload = "[ERROR] No current song active"
            except Exception as e:
                error_msg = f"Error getting current track: {str(e)}"
                logger.error(error_msg)
                if UI:
                    UI.add_log(error_msg)
                payload = f"[ERROR] {error_msg}"
        
        case "current_states":
            try:
                payload = CLIENT.get_playback_states()
            except Exception as e:
                error_msg = f"Error getting playback states: {str(e)}"
                logger.error(error_msg)
                if UI:
                    UI.add_log("Error getting playback states")
                payload = f"[ERROR] {error_msg}"
    
    return payload

# Modifies the currently playing track, like going to the next or previous song, or playing a new song
def modify_current_track(received: str, data: str) -> str:
    payload: str = ""
    
    match (received):
        case "next":
            try:
                CLIENT.run_action(API.next_track)
                if UI:
                    UI.add_log("Next track")
                payload = "[NEXT SONG]"
            except Exception as e:
                error_msg = f"Error going to next song: {str(e)}"
                logger.error(error_msg)
                if UI:
                    UI.add_log(error_msg)
                payload = f"[ERROR] {error_msg}"
        
        case "previous":
            try:
                if (API.current_playback()["progress_ms"] > 4000):
                    CLIENT.run_action(API.seek_track, 0)
                else:
                    CLIENT.run_action(API.previous_track)
                
                if UI:
                    UI.add_log("Previous track")
                payload = "[PREVIOUS SONG]"
            except Exception as e:
                error_msg = f"Error going to previous song: {str(e)}"
                logger.error(error_msg)
                if UI:
                    UI.add_log(error_msg)
                payload = f"[ERROR] {error_msg}"
        
        case "play":
            if (data != None):
                # Format for searching: "<track | album | track,album> <uri>"
                # Format for playing from playlist or album: "<uri> <offset uri>"
                # Format for playing from queue: "<offset uri>"
                play_data: list[str] = data.split(" ")
                try:
                    match (DISPLAY):
                        case "search":
                            if (play_data[0] == "track"):
                                API.start_playback(uris=[play_data[1]]) # Plays just the selected song
                                if UI:
                                    UI.add_log(f"Playing selected searched song")
                                payload = "[PLAY] Played selected searched song"
                        
                        case "queue":
                            API.start_playback(context_uri=API.currently_playing()["context"]["uri"], offset={"uri": play_data[1]}) # Plays song in the queue that was clicked on
                            if UI:
                                UI.add_log(f"Playing selected song in queue")
                            payload = "[PLAY] Played selected song in queue"
                        
                        case "playlist" | "album":
                            if (len(play_data) == 3):
                                API.start_playback(context_uri=play_data[1], offset={"uri": play_data[2]}) # Plays song in the playlist/album that was clicked on
                                if UI:
                                    UI.add_log(f"Playing selected song in playlist/album")
                                payload = "[PLAY] Played selected song in playlist/album"
                            else:
                                API.start_playback(context_uri=play_data[1]) # Plays the playlist/album that was clicked on
                                if UI:
                                    UI.add_log(f"Playing selected playlist/album")
                                payload = "[PLAY] Played selected playlist/album"
                        
                        case _:
                            # Handle unknown display mode
                            error_msg = f"Unknown display mode: {DISPLAY}"
                            logger.warning(error_msg)
                            if UI:
                                UI.add_log(error_msg)
                            payload = f"[ERROR] {error_msg}"
                            
                except Exception as e:
                    error_msg = f"Error playing song: {str(e)}"
                    logger.error(error_msg)
                    if UI:
                        UI.add_log(error_msg)
                    payload = f"[ERROR] {error_msg}"

    return payload

# Modifies the playback states, like pausing, resuming, or changing the shuffle state
def modify_playback_states(received: str) -> str:
    payload: str = ""
    
    if (received == "pause" or received == "resume"):
        try:
            _ = API.current_user_playing_track()['is_playing']
        except Exception as e:
            logger.warning(f"Error checking play state: {str(e)}")
            _ = False
        
        playing = "False" if _ else "True"
        
        try:
            CLIENT.run_action(API.pause_playback) if _ else CLIENT.run_action(API.start_playback)
            
            if UI:
                UI.add_log("Playback " + ("paused" if _ else "resumed"))
            
            payload = CLIENT.get_playback_states(playing=playing)
        except Exception as e:
            error_msg = f"Error pausing/resuming playback: {str(e)}"
            logger.error(error_msg)
            if UI:
                UI.add_log(error_msg)
            payload = f"[ERROR] {error_msg}"
             
    match (received):       
        case "shuffle":
            try:
                shuffle: bool = API.current_playback()["shuffle_state"]
                CLIENT.run_action(API.shuffle, not shuffle) # Throws an error if it can't change the shuffle state
                
                if UI:
                    UI.add_log(f"Shuffle {'disabled' if shuffle else 'enabled'}")
                
                payload = CLIENT.get_playback_states(shuffle=str(not shuffle))
            except Exception as e:
                error_msg = f"Error changing shuffle state: {str(e)}"
                logger.error(error_msg)
                if UI:
                    UI.add_log(error_msg)
                payload = f"[ERROR] {error_msg}"
        
        case "repeat":
            try:
                states: list[str] = ["track", "context", "off"]
                repeat: str       = API.current_playback()["repeat_state"]
                change: str       = states[(states.index(repeat) + 1) if (repeat != "off") else 0]
                CLIENT.run_action(API.repeat, change) # Throws an error if it can't change the repeat state

                if UI:
                    UI.add_log(f"Repeat mode: {change.capitalize()}")

                payload = CLIENT.get_playback_states(repeat=change.capitalize())
            except Exception as e:
                error_msg = f"Error changing repeat state: {str(e)}"
                logger.error(error_msg)
                if UI:
                    UI.add_log(error_msg)
                payload = f"[ERROR] {error_msg}"
    
    return payload

# Lists results stuff, such as playlists, currently playing queue, or search results
def list_stuff(received: str, data: str) -> str:
    global DISPLAY
    payload: str = ""
    
    match (received):
        case "list_playlists":
            DISPLAY = "playlists"
            try:
                payload = CLIENT.get_playlists()
            except Exception as e:
                error_msg = f"Error listing playlists: {str(e)}"
                logger.error(error_msg)
                if UI:
                    UI.add_log(error_msg)
                payload = f"[ERROR] {error_msg}"

        case "search":
            try:
                DISPLAY = "search"
                search_data: list[str] = data.split(" ") # Format: "<type> <search query>"
                
                if (len(search_data) > 1):
                    if UI:
                        UI.add_log(f"Searching for {search_data[0]}: {' '.join(search_data[1:])}")
                    
                    search_results = API.search(" ".join(search_data[1:]), type=search_data[0], market="US") # Valid arguments for type: "track", "album", "track,album"
                    
                    search_split = search_data[0].split(",")
                    if (len(search_split) > 1): # If the search is for more than one type
                        payload = ""
                        for type in search_split:
                            res = search_results[f"{type}s"]
                            payload += CLIENT.get_results(res, ws_call="search") if type != "artist" else CLIENT.get_artists(res)
                    elif (search_data[0] == "artist"):
                        payload = CLIENT.get_artists(search_results["artists"])
                    else:
                        payload = CLIENT.get_results(search_results[f"{search_data[0]}s"], ws_call="search")
                else:
                    error_msg = "Invalid search format. Expected: <type> <search query>"
                    logger.warning(error_msg)
                    if UI:
                        UI.add_log(error_msg)
                    payload = f"[ERROR] {error_msg}"
            except Exception as e:
                error_msg = f"Error searching: {str(e)}"
                logger.error(error_msg)
                if UI:
                    UI.add_log(error_msg)
                payload = f"[ERROR] {error_msg}"
            
        case "list_queue":
            try:
                _ = API.queue()["queue"][0] # Throws an error if there's no queue available
                
                DISPLAY = "queue"
                if UI:
                    UI.add_log("Listing queue")
                payload = CLIENT.get_results(API.queue(), ws_call="queue", keyword="queue")
            except Exception as e:
                error_msg = f"No queue found or error accessing queue: {str(e)}"
                logger.warning(error_msg)
                if UI:
                    UI.add_log("No queue found")
                payload = "[ERROR] No queue found"
    
    return payload

# Displays tracks in an album or playlist
def display_info(received: str, data: str) -> str:
    global DISPLAY
    payload: str = ""
    
    match (received):
        case "display_album":
            # Data format: <album uri>
            try:
                DISPLAY = "album"
                _ = API.album_tracks(data)["items"][0] # Throws an error if there are no tracks in the album
            
                album_info = API.album(data)
                if UI:
                    UI.add_log(f"Displaying album: {album_info['name']}")
                
                payload = CLIENT.display_album(album_info)
            except Exception as e:
                error_msg = f"Error loading album tracks: {str(e)}"
                logger.error(error_msg)
                if UI:
                    UI.add_log(error_msg)
                payload = f"[ERROR] {error_msg}"

        case "display_playlist":
            # Data format: <playlist uri> <offset>
            DISPLAY = "playlist"
            spl = data.split(" ")
            try:
                if ("collection" in spl[0]):
                    _ = API.current_user_saved_tracks()["items"][0] # Throws an error if there are no tracks in their Liked Songs
                    
                    if UI:
                        UI.add_log("Displaying Liked Songs")
                    
                    payload = CLIENT.display_playlist(API.current_user_saved_tracks(), offset=int(spl[1]), uri=spl[0])
                else:
                    playlist_info = API.playlist(playlist_id=spl[0])
                    _ = playlist_info["tracks"]["items"] # Throws an error if there are no tracks in the playlist
                    
                    if UI:
                        UI.add_log(f"Displaying playlist: {playlist_info['name']}")
                
                    payload = CLIENT.display_playlist(playlist_info, offset=int(spl[1]))
            except IndexError as e:
                error_msg = f"Invalid playlist data format: {str(e)}. Expected: <playlist uri> <offset>"
                logger.error(error_msg)
                if UI:
                    UI.add_log(error_msg)
                payload = f"[ERROR] {error_msg}"
            except Exception as e:
                error_msg = f"Error loading playlist tracks: {str(e)}"
                logger.error(error_msg)
                if UI:
                    UI.add_log("Error loading playlist tracks")
                payload = f"[ERROR] {error_msg}"
        
        case "display_artist":
            # Data format: <artist uri>
            DISPLAY = "artist"
            try:
                artist_info = API.artist(data)
                _ = API.artist_top_tracks(data)["tracks"][0] # Throws an error if the artist has no tracks
                
                if UI:
                    UI.add_log(f"Displaying artist: {artist_info['name']}")
                
                payload = CLIENT.display_artist(artist_info, API.artist_top_tracks(data), API.artist_albums(data))
            except Exception as e:
                error_msg = f"Error loading artist: {str(e)}"
                logger.error(error_msg)
                if UI:
                    UI.add_log("Error loading artist")
                payload = f"[ERROR] {error_msg}"
    
    return payload

# Process a single command from a websocket client
async def process_command(received, data, session, client_id):
    """Process a single command and return the payload
    
    Args:
        received: The command to process
        data: Any additional data for the command
        session: The aiohttp session for API calls
        client_id: ID of the client for logging
        
    Returns:
        The payload to send back to the client
    """
    try:
        payload = ""
        if received in ["current_info", "current_track", "current_states"]:
            # Pass the session for Canvas API calls
            payload = await display_current_info(received, session)
            
        elif received in ["next", "previous", "play"]:
            payload = modify_current_track(received, data)

        elif received in ["pause", "resume", "shuffle", "repeat"]:
            payload = modify_playback_states(received)
            
        elif received in ["list_playlists", "search", "list_queue"]:
            payload = list_stuff(received, data)
        
        elif received in ["display_album", "display_playlist", "display_artist"]:
            payload = display_info(received, data)
        
        else:
            if UI:
                UI.add_log(f"Unknown command: {received}")
            payload = "[ERROR] Unknown command"
            
        return payload
    except Exception as e:
        error_msg = f"Error processing command {received}: {str(e)}"
        logger.error(error_msg)
        if UI:
            UI.add_log(f"[ERROR] Failed to process command: {received}")
        return f"[ERROR] Failed to process command: {str(e)}"

# Websocket connection handler using async processing for better concurrency
async def socket(websocket):
    global DISPLAY, UI
    
    # Initializing the websocket
    ID = str(websocket.id)
    if UI:
        UI.add_log(f"Client {ID[:8]} connected!")
        UI.set_client_status(True, ID[:8])
        logger.info(f"Client {ID[:8]} connected")
    
    await websocket.send(CLIENT.get_playback_states())
    
    try:
        async for message in websocket:
            # Message format: "command" "extra data"
            parsed: list[str] = message.removesuffix(" ").split(" ")
            received: str     = ""
            data: str | None  = None
            
            if (len(parsed) < 2):
                received = message
                if UI and LOG_DEBUG_MESSAGES:
                    UI.add_log(f"Client {ID[:8]} command: {received}")
                logger.debug(f"Client {ID[:8]} command: {received}")
            else:
                received = parsed[0]
                data     = " ".join(parsed[1:])
                if UI and LOG_DEBUG_MESSAGES:
                    UI.add_log(f"Client {ID[:8]} command: {received} | {data}")
                logger.debug(f"Client {ID[:8]} command: {received} | {data}")

            # Process commands with improved error handling
            try:
                payload = ""
                
                if received in ["current_info", "current_track", "current_states"]:
                    # For current info commands, we need a session for API calls
                    # But for basic functionality we can skip Canvas API calls
                    payload = await display_current_info(received, None)
                    
                elif received in ["next", "previous", "play"]:
                    payload = modify_current_track(received, data)

                elif received in ["pause", "resume", "shuffle", "repeat"]:
                    payload = modify_playback_states(received)
                    
                elif received in ["list_playlists", "search", "list_queue"]:
                    payload = list_stuff(received, data)
                
                elif received in ["display_album", "display_playlist", "display_artist"]:
                    payload = display_info(received, data)
                
                else:
                    if UI:
                        UI.add_log(f"Unknown command: {received}")
                    payload = "[ERROR] Unknown command"
                    
                if DEBUG and payload != "" and LOG_DEBUG_MESSAGES:
                    if UI:
                        UI.add_log(f"Response sent: {payload[:50]}..." if len(payload) > 50 else f"Response sent: {payload}")
                        
                await websocket.send(payload)
                
            except Exception as e:
                logger.error(f"Error processing command {received}: {str(e)}")
                if UI:
                    UI.add_log(f"[ERROR] Failed to process command: {received}")
                await websocket.send(f"[ERROR] Failed to process command: {str(e)}")
                
    except ws_exceptions.ConnectionClosed:
        logger.info(f"Client {ID[:8]} disconnected")
        if UI:
            UI.add_log(f"Client {ID[:8]} disconnected")
            UI.set_client_status(False)
    except Exception as e:
        logger.error(f"Connection error with client {ID[:8]}: {str(e)}")
        if UI:
            UI.add_log(f"Connection error with client {ID[:8]}")
            UI.set_client_status(False)

def curses_main(stdscr):
    global UI, API, CLIENT
    
    # Initialize UI
    UI = SpotipyUI(stdscr, CLIENT)
    
    # Wait for user to quit
    while True:
        try:
            key = stdscr.getch()
            if key == ord('q'):  # Quit on 'q'
                break
            elif key == ord('r'):  # Refresh on 'r'
                stdscr.clear()
                stdscr.refresh()
            elif key == ord('m'):  # Monitor memory usage on 'm'
                if MEMORY_TRACKING:
                    UI.add_log("Monitoring memory usage...")
                    log_memory_usage()
                    UI.add_log("Memory usage logged")
                else:
                    UI.add_log("Memory tracking not available (install pympler)")
            elif key == ord('s'):  # Debug Spotify API connection on 's'
                UI.add_log("Checking Spotify API connection status...")
                try:
                    if API and CLIENT:
                        # Test token validity
                        devices = API.devices()
                        if devices:
                            UI.add_log(f"Spotify API connected. Found {len(devices['devices'])} device(s)")
                            # Try to manually update now playing
                            current = API.current_user_playing_track()
                            if current and 'item' in current and current['item']:
                                track_name = current['item'].get('name', 'Unknown')
                                artist_name = current['item']['artists'][0].get('name', 'Unknown') if current['item']['artists'] else 'Unknown'
                                UI.add_log(f"Current track: {track_name} - {artist_name}")
                            else:
                                UI.add_log("No track currently playing")
                        else:
                            UI.add_log("No devices found. Please open Spotify app")
                    else:
                        UI.add_log("API not initialized. Reconnecting...")
                        connect_to_spotify()
                        UI.add_log("Reconnection attempt completed")
                except Exception as e:
                    UI.add_log(f"Spotify API connection error: {str(e)}")
                    UI.add_log("Attempting to reconnect...")
                    try:
                        connect_to_spotify()
                        UI.add_log("Reconnection attempt completed")
                    except Exception as e2:
                        UI.add_log(f"Reconnection failed: {str(e2)}")
            elif key == ord('d'):  # Debug Spotify devices on 'd'
                UI.add_log("Checking Spotify devices...")
                device_info = find_spotify_devices()
                UI.add_log(device_info)

                # Show more details about authentication
                if API and hasattr(API, 'auth_manager'):
                    try:
                        token_info = API.auth_manager.get_cached_token()
                        if token_info:
                            # Calculate token expiration
                            if 'expires_at' in token_info:
                                expires_at = token_info['expires_at']
                                current_time = int(time.time())
                                minutes_left = (expires_at - current_time) // 60
                                UI.add_log(f"Token expires in {minutes_left} minutes")
                            
                            # Show scopes
                            if 'scope' in token_info:
                                scopes = token_info['scope'].split(' ')
                                UI.add_log(f"Token has {len(scopes)} scopes: {', '.join(scopes[:3])}...")
                    except Exception as e:
                        UI.add_log(f"Error getting token info: {str(e)}")
                
                # Show CLIENT details
                if CLIENT:
                    if hasattr(CLIENT, '_device') and CLIENT._device:
                        UI.add_log(f"CLIENT using device: {CLIENT._device}")
                    else:
                        UI.add_log("CLIENT has no active device")
                        
                        # Try to select a device automatically
                        try:
                            UI.add_log("Attempting to select a device...")
                            CLIENT.find_device()
                            if CLIENT._device:
                                UI.add_log(f"Selected device: {CLIENT._device}")
                            else:
                                UI.add_log("Failed to select a device automatically")
                        except Exception as e:
                            UI.add_log(f"Error selecting device: {str(e)}")
            elif key == ord('p'):  # Manual now playing refresh on 'p'
                UI.add_log("Manually refreshing Now Playing...")
                try:
                    if API and CLIENT:
                        # Get current playback
                        current_playback = API.current_playback()
                        
                        # Manually update the now playing component
                        UI.now_playing.render(current_playback)
                        UI.stdscr.refresh()
                        
                        # Log playback details
                        if current_playback and 'item' in current_playback and current_playback['item']:
                            track_name = current_playback['item'].get('name', 'Unknown')
                            artist_name = current_playback['item']['artists'][0].get('name', 'Unknown') if current_playback['item']['artists'] else 'Unknown'
                            progress = current_playback.get('progress_ms', 0)
                            duration = current_playback['item'].get('duration_ms', 0)
                            is_playing = current_playback.get('is_playing', False)
                            
                            status = "Playing" if is_playing else "Paused"
                            UI.add_log(f"{status}: {track_name} - {artist_name} [{progress//1000}s/{duration//1000}s]")
                        else:
                            UI.add_log("No track currently playing")
                except Exception as e:
                    UI.add_log(f"Error refreshing playback: {str(e)}")
            elif key == ord('c'):  # Test Canvas functionality
                UI.add_log("Testing Canvas API...")
                # Use requests for synchronous call in this context
                try:
                    test_track_id = "3OHfY25tqY28d16oZczHc8"  # SZA
                    response = requests.get(f"{CANVAS_API_URL}?trackId={test_track_id}")
                    if response.status_code == 200:
                        data = response.json()
                        if data and "canvasesList" in data and len(data["canvasesList"]) > 0:
                            canvas = data["canvasesList"][0]
                            UI.add_log(f"Canvas found: {canvas.get('canvasUrl', 'N/A')[:30]}...")
                            if "artist" in canvas and canvas["artist"]:
                                UI.add_log(f"Artist: {canvas['artist'].get('artistName', 'Unknown')}")
                                UI.add_log(f"Artist image: {canvas['artist'].get('artistImgUrl', 'N/A')[:30]}...")
                        else:
                            UI.add_log("No canvas found in test")
                    else:
                        UI.add_log(f"Canvas API test failed: {response.status_code}")
                except Exception as e:
                    UI.add_log(f"Canvas test error: {str(e)}")
        except KeyboardInterrupt:
            break
    
    # Shutdown UI
    if UI:
        UI.shutdown()

async def main():
    global API, CLIENT, UI
    
    # Create a shutdown event
    shutdown_event = aio.Event()
    
    # Define a shutdown handler
    def shutdown_signal(signal, frame):
        if UI:
            UI.add_log("Shutting down...")
        logger.warning("Server shutting down")
        shutdown_event.set()
    
    # Register the signal handlers
    signal.signal(signal.SIGINT, shutdown_signal)
    signal.signal(signal.SIGTERM, shutdown_signal)
    
    # Create cache directories if they don't exist
    os.makedirs("spotify_cache", exist_ok=True)
    os.makedirs("spotify_http_cache", exist_ok=True)
    
    # Connect to Spotify
    logger.info("Connecting to Spotify API")
    if not connect_to_spotify():
        logger.error("Failed to connect to Spotify")
        print("Failed to connect to Spotify")
        return
    logger.success("Connected to Spotify API successfully")
    
    # Pre-warm cache for common operations (in parallel)
    try:
        logger.info("Pre-warming caches...")
        cache_tasks = []
        
        # Start the UI in a separate thread
        ui_thread = threading.Thread(target=lambda: curses.wrapper(curses_main))
        ui_thread.daemon = True
        ui_thread.start()
        
        # Start the server
        logger.info(f"Starting WebSocket server on localhost:{PORT}")
        server = await ws_server.serve(socket, 'localhost', PORT)
        logger.success(f"WebSocket server running on localhost:{PORT}")
        
        # Execute cache pre-warming tasks in parallel while server is starting
        if cache_tasks:
            await aio.gather(*cache_tasks)
            logger.debug("Cache pre-warming complete")
        
        # Wait for the shutdown event
        await shutdown_event.wait()
    finally:
        # Clean shutdown
        logger.info("Performing clean shutdown...")
        
        # Close server
        try:
            server.close()
            await server.wait_closed()
            logger.debug("WebSocket server closed")
        except Exception as e:
            logger.error(f"Error closing server: {e}")
        
        # Flush and close caches
        try:
            disk_cache.close()
            logger.debug("Disk cache closed")
        except Exception as e:
            logger.warning(f"Error closing disk cache: {e}")
        
        # Final UI shutdown
        if UI:
            UI.add_log("Server has been shut down.")
            time.sleep(0.5)  # Give UI time to display the message
            UI.shutdown()
        
        # Final cleanup
        if MEMORY_TRACKING:
            await aio.to_thread(log_memory_usage)
        
        logger.warning("Server has shut down successfully")

if __name__ == '__main__':
    import argparse as arg
    parser = arg.ArgumentParser(description="The websocket server for the Resonite Spotipy project")
    parser.add_argument("-d", "--debug", dest="debug", action="store_true", help="Prints debug messages", default=False)
    parser.add_argument("--log-level", dest="log_level", type=int, choices=[1, 2, 3, 4], 
                       help="Set log level (1=ERROR, 2=INFO, 3=DEBUG, 4=TRACE)", default=2)
    parser.add_argument("--memory-track", dest="memory_track", action="store_true", 
                       help="Enable memory tracking (requires pympler)", default=False)
    parser.add_argument("--optimize", dest="optimize", action="store_true",
                       help="Enable performance optimizations (caching)", default=True)
    args = parser.parse_args()
    
    DEBUG = args.debug
    
    # Initialize logging with loguru
    logger.remove()  # Remove default handler
    log_level = {1: "ERROR", 2: "INFO", 3: "DEBUG", 4: "TRACE"}[args.log_level]
    logger.add(sys.stderr, level=log_level)
    logger.add("resonite_spotipy.log", rotation="10 MB", compression="zip", 
              level=log_level, format="{time:YYYY-MM-DD HH:mm:ss} | {level} | {message}")
    
    logger.info(f"Starting ResoniteSpotipy with log level: {log_level}")
    
    # Enable spotify_color debug at the same level
    spotify_color.enable_debug(level=args.log_level)
    
    # Initialize optimizations
    if args.optimize:
        logger.info("Performance optimizations enabled (caching)")
        # Ensure cache directories exist
        os.makedirs("spotify_cache", exist_ok=True)
        os.makedirs("spotify_http_cache", exist_ok=True)
        os.makedirs("color_cache", exist_ok=True)
        os.makedirs("album_art_cache", exist_ok=True)
    else:
        logger.warning("Performance optimizations disabled")
        # Disable caching
        extract_track_id_cache.cache_clear()
        extract_track_id_cache.cache_parameters.maxsize = 0
    
    # Enable memory tracking if requested
    if args.memory_track and MEMORY_TRACKING:
        logger.info("Memory tracking enabled")
    elif args.memory_track and not MEMORY_TRACKING:
        logger.warning("Memory tracking requested but pympler not available")
    
    try:
        aio.run(main())
    except KeyboardInterrupt:
        # Already handled
        pass
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        print(f"Unexpected error: {e}")
        sys.exit(1)